package net.mguenther.idem.flake;

import net.mguenther.idem.Wait;
import net.mguenther.idem.encoder.LongEncoder;
import net.mguenther.idem.provider.LinearTimeProvider;
import net.mguenther.idem.provider.StaticWorkerIdProvider;
import net.mguenther.idem.provider.TimeProvider;
import org.junit.Before;
import org.junit.Test;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import static net.mguenther.idem.TestUtil.assertThatListIsStrictlyOrdered;
import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

public class Flake64Test {

    private static final long MAX_DEVIATION_ALLOWED = 10L;

    private final TimeProvider timeProvider = new LinearTimeProvider();

    private Flake64<Long> flake;

    @Before
    public void prepareTest() {
        flake = new Flake64L(
                timeProvider,
                new StaticWorkerIdProvider("ASvmcvljs=!"), // this worker ID has its LSB set to 1
                new LongEncoder());
    }

    @Test
    public void timeSegmentShouldBeCorrectlyAligned() {
        // we check alignment by extracting the timestamp part from the generated ID
        // and compare the timestamp with what the TimeProvider yields. we expect that
        // both the newly obtained timestamp and the timestamp from the ID be within
        // milliseconds of each other and test for a maximum difference of
        // MAX_DEVIATION_ALLOWED. this would not be case if the segment would not be
        // at the proper place (bit-wise) in the generated ID
        long id = flake.nextId();
        long now  = timeProvider.getTimestamp() & Flake64.TIMESTAMP_LOWER_BITS;
        long timestampFromId = id >> 22;
        assertTrue(now - timestampFromId < MAX_DEVIATION_ALLOWED);
    }

    @Test
    public void sequenceNumberShouldBeCorrectlyAligned() {
        // we check if the lower bits that are reserved for the sequence number are
        // zero (the first sequence number for a time slot ms-wise). if the sequence
        // number part would be overlapping with any of the other segments, then this
        // would not be zero if we use a worker ID for which the encoded worker ID
        // has its LSB set to 1 (as is the case with the worker ID used in this test)
        long id = flake.nextId();
        long sequenceNumber = (id & Flake64.SEQUENCE_LOWER_BITS);
        assertThat(sequenceNumber, is(0L));
    }

    @Test
    public void generatedIdsShouldBeLinearlyIncreasingAcrossTimeSlots() {
        List<Long> generatedIds = new ArrayList<>();
        long started = System.nanoTime();
        while (System.nanoTime() - started < 200_000_000L) {
            generatedIds.add(flake.nextId());
        }
        assertFalse(generatedIds.isEmpty());
        assertThatListIsStrictlyOrdered(generatedIds);
    }

    @Test
    public void shouldIsolateProcessesProperlyByWorkerIds() throws InterruptedException {

        Flake64Worker worker1 = new Flake64Worker(new Flake64L(timeProvider, new StaticWorkerIdProvider("A"), new LongEncoder()));
        Flake64Worker worker2 = new Flake64Worker(new Flake64L(timeProvider, new StaticWorkerIdProvider("B"), new LongEncoder()));

        Thread workerThread1 = new Thread(worker1);
        Thread workerThread2 = new Thread(worker2);

        workerThread1.start();
        workerThread2.start();

        Wait.delay(1, TimeUnit.SECONDS);

        worker1.stop();
        worker2.stop();

        workerThread1.join(1_000);
        workerThread2.join(1_000);

        List<Long> generatedIdsByWorker1 = worker1.getGeneratedIds();
        List<Long> generatedIdsByWorker2 = worker2.getGeneratedIds();

        Set<Long> combinedGeneratedIds = new HashSet<>();
        combinedGeneratedIds.addAll(generatedIdsByWorker1);
        combinedGeneratedIds.addAll(generatedIdsByWorker2);

        // the combined set of IDs would be smaller in size than the sum of the individual lists of
        // generated IDs, if we'd experience any duplicates between the IDs generated by worker 1
        // and those generated by worker 2
        assertThat(combinedGeneratedIds.size(), is(generatedIdsByWorker1.size() + generatedIdsByWorker2.size()));
    }

    private class Flake64Worker implements Runnable {

        private final Flake64<Long> flake;

        private final List<Long> generatedIds;

        private volatile boolean running = true;

        public Flake64Worker(final Flake64<Long> flake) {
            this.flake = flake;
            this.generatedIds = new ArrayList<>();
        }

        @Override
        public void run() {
            while (running) {
                generatedIds.add(flake.nextId());
            }
        }

        public void stop() {
            running = false;
        }

        public List<Long> getGeneratedIds() {
            return generatedIds;
        }
    }
}
